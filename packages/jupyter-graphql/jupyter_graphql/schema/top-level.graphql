type Query {
  node(id: ID!): Node

  kernelspecs: [KernelSpec!]!
  kernelspec(name: String!): KernelSpec
  kernelspecByID(id: ID!): KernelSpec

  kernels: [Kernel!]!
  """
  Maybe in future we should just remove this `kernelByID` and make that the default? Only allow opaque IDs to look up kernels?

  Ideally would allow union type as input, to allow either ID or kernel_id to query...

  TODO: Should we send kernel info request to make sure this stuff is up to date like execution_state?
  """
  kernel(kernelID: String!): Kernel
  kernelByID(id: ID!): Kernel

  execution(id: ID!): Execution

  comms: [Comm]
}

type Mutation {
  """
  Start a new kernel.

  Sends a kernel info request after starting.
  """
  startKernel(input: StartKernelInput!): StartKernelPayload
  """
  Trigger a kernel to shutdown.

  Q: Should this wait till it actually shuts down to return or as soon as shut
  down has been triggered?

  This will block until the kernel shuts down to return.
  """
  stopKernel(input: StopKernelInput!): StopKernelPayload
  """
  Interrupt a kernel, giving the response once the message has been sent.

  If the interrupt mode of the kernelspec is signal, it will send a SIGINT,
  if it is message, it will send an `interrupt_request` message.
  """
  interruptKernel(input: InterruptKernelInput!): InterruptKernelPayload
  """
  Restart a kernel. Any messages sent while the kernel is restarting will be queued
  for the next kernel.

  Sends a kernel info request after restarting.
  """
  restartKernel(input: RestartKernelInput!): RestartKernelPayload

  """
  Start executing some code. Does not block for code to finish executing.
  """
  execute(input: ExecuteInput!): ExecutePayload

  """
  Ask the kernel for information about some code. Blocks till response.
  """
  inspect(input: InspectInput!): InspectPayload

  """
  Ask the kernel to do code completion
  """
  complete(input: CompleteInput!): CompletePayload

  # Note that we don't include history for now, given not supported that well or used.
  # https://jupyter-client.readthedocs.io/en/stable/messaging.html#history
  # > Most of the history messaging options are not used by Jupyter frontends, and many kernels do not implement them. If you’re implementing these messages in a kernel, the ‘tail’ request is the most useful; this is used by the Qt console, for example. The notebook interface does not use history messages at all.
  # > This interface was designed by exposing all the main options of IPython’s history interface. We may remove some options in a future version of the message spec.

  """
  Asks a kernel if the code is complete.

  When the user enters a line in a console style interface, the console must decide whether to immediately execute the current code, or whether to show a continuation prompt for further input. For instance, in Python `a = 5` would be executed immediately, while `for i in range(5):` would expect further input.
  """
  isComplete(input: IsCompleteInput!): IsCompletePayload

  """
  This message type is used with debugging kernels to request specific actions to be performed by the debugger such as adding a breakpoint or stepping into a code.
  """
  debug(input: DebugInput!): DebugPayload

  """
  Reply to an input request on a exection.
  """
  reply(input: ReplyInput!): ReplyPayload

  openComm(input: OpenCommInput!): OpenCommPayload

  commMessage(input: CommMessageInput!): CommMessagePayload

  closeComm(input: CloseCommInput!): CloseCommPayload
}

type Subscription {
  """
  Triggers whenever a kernel status is updated and completes when it is deleted.
  """
  kernelExecutionStateUpdated(id: ID!): Kernel
  """
  Triggers whenever a new kernel is created.
  """
  kernelCreated: Kernel!
  """
  Triggers whenever a kernel is deleted.
  """
  kernelDeleted: ID!

  """
  Listen to debug events for a certain kernel, returns the content as JSON string.
  """
  debugEvent(kernelID: ID!): JSON!

  """
  Listen to events about an execution
  """
  executionEvents(executionID: ID!): ExecutionEventPayload

  """
  Listen to messages about this comm, closed when comm is closed
  """
  commMessages(ID: ID!): CommMessage!
}
