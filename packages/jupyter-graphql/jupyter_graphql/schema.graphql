"""
An object with a globally unique `ID`.
"""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
}

"""
A location in a connection that can be used for resuming pagination.
"""
scalar Cursor

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}

"""
JSON serialized as a string.
"""
scalar JSON

"""
Kernel Specification.

Provides all fields from KernelSpec file as defined in
[Jupyter Client docs](https://jupyter-client.readthedocs.io/en/stable/kernels.html#kernelspecs).
"""
type KernelSpec implements Node {
  id: ID!

  """
  A unique kernel name.
  """
  name: String!

  """
  A list of command line arguments used to start the kernel.
  The text `{connection_file}` in any argument will be replaced with the path to the connection file.
  """
  argv: [String!]!

  """
  The kernel’s name as it should be displayed in the UI. Unlike the kernel name used in the API, this can contain arbitrary unicode characters.
  """
  displayName: String!

  """
  The name of the language of the kernel. When loading notebooks, if no matching kernelspec key (may differ across machines) is found, a kernel with a matching language will be used. This allows a notebook written on any Python or Julia kernel to be properly associated with the user’s Python or Julia kernel, even if they aren’t listed under the same name as the author’s.
  """
  language: String!

  """
  Assumes the default of `SIGNAL` if it is not specified in the spec file.
  """
  interruptMode: KernelSpecInterruptMode!

  """
  A dictionary of environment variables to set for the kernel. These will be added to the current environment variables before the kernel is started. Existing environment variables can be referenced using `${<ENV_VAR>}` and will be substituted with the corresponding value. Administrators should note that use of `${<ENV_VAR>}` can expose sensitive variables and should use only in controlled circumstances.
  """
  env: JSON!
  """
  A dictionary of additional attributes about this kernel; used by clients to aid in kernel selection. Metadata added here should be namespaced for the tool reading and writing that metadata.
  """
  metadata: JSON!
}

"""
Specifies how a client is supposed to interrupt cell execution on this kernel.
"""
enum KernelSpecInterruptMode {
  "Send an interrupt signal via the operating system’s signalling facilities (e.g. `SIGINT` on POSIX systems)"
  SIGNAL
  "Send an `interrupt_request` message on the control channel (see Kernel interrupt)."
  MESSAGE
}

type Query {
  node(id: ID!): Node
  kernelspecs: [KernelSpec!]!
  kernelspec(name: String!): KernelSpec
  kernelspecByID(id: ID!): KernelSpec
  execution(id: ID!): Execution
}

type Execution implements Node {
  id: ID!
  code: String!
  status: ExecutionStatus!
  displays(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
  ): DisplaysConnection!
}

type DisplaysConnection {
  edges: [DisplaysEdge!]!
  pageInfo: PageInfo!
}

type DisplaysEdge {
  cursor: Cursor!
  node: Display!
}

union ExecutionStatus =
    ExecutionStatusOK
  | ExecutionStatusAbort
  | ExecutionStatusError
  | ExecutionStatusPending

type ExecutionStatusOK {
  executionCount: Int
  result: ExecutionResult
}

type ExecutionResult {
  """
  Data as JSON.

  We could represent as map, and add pagination, if we want to add support
  for just getting some data or metadata, but not all of it.
  """
  data: JSON!
  metadata: JSON!
}

type ExecutionStatusError {
  name: String!
  value: String!
  traceback: [String!]!
}

type ExecutionStatusAbort {
  _: Boolean
}

type ExecutionStatusPending {
  _: Boolean
}

union Display = DisplayStream | DisplayData

enum DisplayStreamName {
  STDOUT
  STDERR
}

type DisplayStream {
  name: DisplayStreamName!
  text: String!
}

type DisplayData {
  data: JSON!
  metadata: JSON!
  displayID: String
}
