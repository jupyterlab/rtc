"""
An object with a globally unique `ID`.
"""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
}

"""
A location in a connection that can be used for resuming pagination.
"""
scalar Cursor

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}

"""
JSON serialized as a string.
"""
scalar JSON

"""
Kernel Specification.

Provides all fields from KernelSpec file as defined in
[Jupyter Client docs](https://jupyter-client.readthedocs.io/en/stable/kernels.html#kernelspecs).

*TODO*: Add resources
"""
type KernelSpec implements Node {
  id: ID!

  """
  A unique kernel name.
  """
  name: String!

  """
  A list of command line arguments used to start the kernel.
  The text `{connection_file}` in any argument will be replaced with the path to the connection file.
  """
  argv: [String!]!

  """
  The kernel’s name as it should be displayed in the UI. Unlike the kernel name used in the API, this can contain arbitrary unicode characters.
  """
  displayName: String!

  """
  The name of the language of the kernel. When loading notebooks, if no matching kernelspec key (may differ across machines) is found, a kernel with a matching language will be used. This allows a notebook written on any Python or Julia kernel to be properly associated with the user’s Python or Julia kernel, even if they aren’t listed under the same name as the author’s.
  """
  language: String!

  """
  Assumes the default of `SIGNAL` if it is not specified in the spec file.
  """
  interruptMode: KernelSpecInterruptMode!

  """
  A dictionary of environment variables to set for the kernel. These will be added to the current environment variables before the kernel is started. Existing environment variables can be referenced using `${<ENV_VAR>}` and will be substituted with the corresponding value. Administrators should note that use of `${<ENV_VAR>}` can expose sensitive variables and should use only in controlled circumstances.
  """
  env: JSON!
  """
  A dictionary of additional attributes about this kernel; used by clients to aid in kernel selection. Metadata added here should be namespaced for the tool reading and writing that metadata.
  """
  metadata: JSON!
}

type Kernel implements Node {
  id: ID!

  """
  ID of the kernel according to the server

  TODO: Do we call this UUID or ID? mismatched terminology on jupyter server
  https://jupyter-server.readthedocs.io/en/latest/developers/rest-api.html#get--api-kernels-kernel_id
  """
  kernelID: String!

  name: String!

  lastActivity: String!

  executionState: KernelExecutionState!

  connections: Int!
}

enum KernelExecutionState  {
  """
  Kernel is busy executing code
  """
  BUSY
  """
  Kernel is idle.
  """
  IDLE
  """
  Kernel is starting
  """
  STARTING

  """
  Kernel is in the middle of restarting
  """
  RESTARTING

  """
  Kernel tried to restart and failed.
  TODO: What does the user do in this case? Try to restart again?
  """
  DEAD
}

"""
Specifies how a client is supposed to interrupt cell execution on this kernel.
"""
enum KernelSpecInterruptMode {
  "Send an interrupt signal via the operating system’s signalling facilities (e.g. `SIGINT` on POSIX systems)"
  SIGNAL
  "Send an `interrupt_request` message on the control channel (see Kernel interrupt)."
  MESSAGE
}

type Query {
  node(id: ID!): Node

  kernelspecs: [KernelSpec!]!
  kernelspec(name: String!): KernelSpec
  kernelspecByID(id: ID!): KernelSpec

  kernels: [Kernel!]!
  """
  Maybe in future we should just remove this `kernelByID` and make that the default? Only allow opaque IDs to look up kernels?

  Ideally would allow union type as input, to allow either ID or kernel_id to query...
  """
  kernel(kernelID: String!): Kernel
  kernelByID(id: ID!): Kernel

  execution(id: ID!): Execution
}

type Mutation {
  """
  Start a new kernel.

  TODO: Should possibly rename create and delete instead?

  TODO: Why should start not send a `kernel_info_request`
  but restarting does? Is this the desired behavior? Is this documented somewhere?
  """
  startKernel(input: StartKernelInput!): StartKernelPayload
  """
  Shutdown and delete a kernel.
  """
  stopKernel(input: StopKernelInput!): StopKernelPayload
  """
  Interrupt a kernel.
  """
  interruptKernel(input: InterruptKernelInput!): InterruptKernelPayload
  """
  Restart a kernel.
  """
  restartKernel(input: RestartKernelInput!): RestartKernelPayload
}


input StartKernelInput {
  clientMutationId: String!

  """
  Kernel spec name (defaults to default kernel spec for server)

  # TODO: Should this be a kernel spec ID instead of a name?
  """
  kernelspecName: String

  """
  API path from root to the cwd of the kernel
  """
  path: String
}

type StartKernelPayload {
  clientMutationId: String!

  """
  The kernel that was started
  """
  kernel: Kernel!
}


"""
TODO: We should probably make this just trigger a interrupt message/kill the kernel
based on the kernelspec?

Or should we allow people to kill as well manually or send interrupt message manually?
"""
input StopKernelInput {
  clientMutationId: String!

  """
  The ID of the kernel to stop
  """
  id: ID!
}

type StopKernelPayload {
  clientMutationId: String!
  """
  The kernel ID that was triggered to stop.
  """
  id: ID!
}


input InterruptKernelInput {
  clientMutationId: String!

  """
  The ID of the kernel to interrupt
  """
  id: ID!
}

type InterruptKernelPayload {
  clientMutationId: String!
  """
  The kernel that was interrupted
  """
  kernel: Kernel!
}

input RestartKernelInput {
  clientMutationId: String!

  """
  The ID of the kernel to restart
  """
  id: ID!
}

type RestartKernelPayload {
  clientMutationId: String!
  """
  The kernel that was restarted
  """
  kernel: Kernel!
}

type Execution implements Node {
  id: ID!
  code: String!
  status: ExecutionStatus!
  displays(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
  ): DisplaysConnection!
}

type DisplaysConnection {
  edges: [DisplaysEdge!]!
  pageInfo: PageInfo!
}

type DisplaysEdge {
  cursor: Cursor!
  node: Display!
}

union ExecutionStatus =
    ExecutionStatusOK
  | ExecutionStatusAbort
  | ExecutionStatusError
  | ExecutionStatusPending

type ExecutionStatusOK {
  executionCount: Int
  result: ExecutionResult
}

type ExecutionResult {
  """
  Data as JSON.

  We could represent as map, and add pagination, if we want to add support
  for just getting some data or metadata, but not all of it.
  """
  data: JSON!
  metadata: JSON!
}

type ExecutionStatusError {
  name: String!
  value: String!
  traceback: [String!]!
}

type ExecutionStatusAbort {
  _: Boolean
}

type ExecutionStatusPending {
  _: Boolean
}

union Display = DisplayStream | DisplayData

enum DisplayStreamName {
  STDOUT
  STDERR
}

type DisplayStream {
  name: DisplayStreamName!
  text: String!
}

type DisplayData {
  data: JSON!
  metadata: JSON!
  displayID: String
}
